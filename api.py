from flask import Flask, jsonify, request, send_file
from flask_cors import CORS
import psycopg2
from psycopg2 import sql
import json
import os
import random
import string
import base64
from io import BytesIO

app = Flask(__name__)
CORS(app)  # Enable CORS for React

# Database connection string
DB_URL = "postgresql://neondb_owner:npg_Jf2LGdNayZ3D@ep-late-bird-ahh0qy4j-pooler.c-3.us-east-1.aws.neon.tech/neondb?sslmode=require"

@app.route('/')
def index():
    """API root endpoint"""
    return jsonify({
        'status': 'online',
        'message': 'Secret Database API',
        'endpoints': {
            'tables': '/api/tables',
            'verify_code': '/api/verify-code',
            'store_code': '/api/store-code'
        }
    })

def get_db_connection():
    return psycopg2.connect(DB_URL)

# In-memory storage for active codes (in production, use Redis or database)
active_codes = {}

@app.route('/api/generate-code', methods=['POST'])
def generate_code():
    """Generate a new secret code"""
    try:
        # Generate random 6-character code
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))

        # Store in memory (expires after use)
        active_codes[code] = True

        # Also save to file for backward compatibility with desktop version
        script_dir = os.path.dirname(os.path.abspath(__file__))
        code_file = os.path.join(script_dir, 'secret_code.json')
        with open(code_file, 'w') as f:
            json.dump({'code': code}, f)

        print(f"[INFO] New code generated: {code}")
        return jsonify({'code': code})
    except Exception as e:
        print(f"[ERROR] {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/store-code', methods=['POST'])
def store_code():
    """Store a code generated by the game (from web version)"""
    try:
        data = request.json
        code = data.get('code', '').strip().upper()

        if not code or len(code) != 6:
            return jsonify({'error': 'Invalid code format'}), 400

        # Store in memory
        active_codes[code] = True

        print(f"[INFO] Code stored from game: {code}")
        return jsonify({'success': True})
    except Exception as e:
        print(f"[ERROR] {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/verify-code', methods=['POST'])
def verify_code():
    """Verify the secret code"""
    try:
        data = request.json
        user_code = data.get('code', '').strip().upper()

        # Check in-memory codes first
        if user_code in active_codes:
            # Remove code after successful use (one-time use)
            del active_codes[user_code]
            print(f"[INFO] Code verified and consumed: {user_code}")
            return jsonify({'valid': True, 'message': 'Code verified!'})

        # Fallback: check file (for desktop version)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        code_file = os.path.join(script_dir, 'secret_code.json')

        if os.path.exists(code_file):
            with open(code_file, 'r') as f:
                code_data = json.load(f)
                valid_code = code_data.get('code', '').strip().upper()

            print(f"[DEBUG] User code: '{user_code}' | Valid code: '{valid_code}' | Match: {user_code == valid_code}")

            if user_code == valid_code:
                return jsonify({'valid': True, 'message': 'Code verified!'})

        return jsonify({'valid': False, 'message': 'Invalid code'}), 401

    except Exception as e:
        print(f"[ERROR] {str(e)}")
        return jsonify({'valid': False, 'message': str(e)}), 500

@app.route('/api/tables', methods=['GET'])
def get_tables():
    """Get list of all tables"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT table_name
            FROM information_schema.tables
            WHERE table_schema = 'public'
            ORDER BY table_name
        """)
        tables = [row[0] for row in cursor.fetchall()]
        cursor.close()
        conn.close()
        return jsonify({'tables': tables})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/tables/<table_name>', methods=['GET'])
def get_table_data(table_name):
    """Get all data from a specific table"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        # Get data
        cursor.execute(sql.SQL("SELECT * FROM {} LIMIT 1000").format(
            sql.Identifier(table_name)
        ))
        rows = cursor.fetchall()
        columns = [desc[0] for desc in cursor.description]

        # Convert to list of dicts
        data = []
        for row in rows:
            data.append(dict(zip(columns, row)))

        cursor.close()
        conn.close()
        return jsonify({
            'columns': columns,
            'data': data
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/tables/<table_name>/rows', methods=['POST'])
def create_row(table_name):
    """Insert a new row"""
    try:
        row_data = request.json

        # Filter out None values
        filtered_data = {k: v for k, v in row_data.items() if v is not None and v != ''}

        if not filtered_data:
            return jsonify({'error': 'No data to insert'}), 400

        conn = get_db_connection()
        cursor = conn.cursor()

        columns = list(filtered_data.keys())
        values = list(filtered_data.values())

        query = sql.SQL("INSERT INTO {} ({}) VALUES ({}) RETURNING *").format(
            sql.Identifier(table_name),
            sql.SQL(', ').join(map(sql.Identifier, columns)),
            sql.SQL(', ').join(sql.Placeholder() * len(values))
        )

        cursor.execute(query, values)
        conn.commit()

        # Get the inserted row
        new_row = cursor.fetchone()
        column_names = [desc[0] for desc in cursor.description]
        result = dict(zip(column_names, new_row))

        cursor.close()
        conn.close()

        return jsonify({'success': True, 'data': result}), 201
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/tables/<table_name>/rows', methods=['PUT'])
def update_row(table_name):
    """Update an existing row"""
    try:
        data = request.json
        old_row = data.get('old')
        new_row = data.get('new')

        if not old_row or not new_row:
            return jsonify({'error': 'Missing old or new row data'}), 400

        conn = get_db_connection()
        cursor = conn.cursor()

        # Get column names
        cursor.execute(sql.SQL("SELECT * FROM {} LIMIT 0").format(
            sql.Identifier(table_name)
        ))
        columns = [desc[0] for desc in cursor.description]

        # Build SET clause
        set_items = []
        set_values = []
        for col in columns:
            if col in new_row:
                set_items.append(sql.SQL("{} = {}").format(sql.Identifier(col), sql.Placeholder()))
                set_values.append(new_row[col])

        # Build WHERE clause
        where_items = []
        where_values = []
        for col in columns:
            if col in old_row:
                where_items.append(sql.SQL("{} = {}").format(sql.Identifier(col), sql.Placeholder()))
                where_values.append(old_row[col])

        query = sql.SQL("UPDATE {} SET {} WHERE {}").format(
            sql.Identifier(table_name),
            sql.SQL(', ').join(set_items),
            sql.SQL(' AND ').join(where_items)
        )

        cursor.execute(query, set_values + where_values)
        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/tables/<table_name>/rows', methods=['DELETE'])
def delete_row(table_name):
    """Delete a row"""
    try:
        row_data = request.json

        conn = get_db_connection()
        cursor = conn.cursor()

        # Get column names
        cursor.execute(sql.SQL("SELECT * FROM {} LIMIT 0").format(
            sql.Identifier(table_name)
        ))
        columns = [desc[0] for desc in cursor.description]

        # Build WHERE clause
        where_items = []
        where_values = []
        for col in columns:
            if col in row_data:
                where_items.append(sql.SQL("{} = {}").format(sql.Identifier(col), sql.Placeholder()))
                where_values.append(row_data[col])

        query = sql.SQL("DELETE FROM {} WHERE {}").format(
            sql.Identifier(table_name),
            sql.SQL(' AND ').join(where_items)
        )

        cursor.execute(query, where_values)
        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# File and Folder Management
@app.route('/api/files/init', methods=['POST'])
def init_files_table():
    """Initialize files table if it doesn't exist"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS files (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                type VARCHAR(10) NOT NULL,
                parent_folder VARCHAR(500) DEFAULT '/',
                file_data TEXT,
                file_size INTEGER DEFAULT 0,
                mime_type VARCHAR(100),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        cursor.close()
        conn.close()
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files', methods=['GET'])
def get_files():
    """Get all files and folders"""
    try:
        folder = request.args.get('folder', '/')
        conn = get_db_connection()
        cursor = conn.cursor()

        # Ensure table exists
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS files (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                type VARCHAR(10) NOT NULL,
                parent_folder VARCHAR(500) DEFAULT '/',
                file_data TEXT,
                file_size INTEGER DEFAULT 0,
                mime_type VARCHAR(100),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()

        cursor.execute("""
            SELECT id, name, type, parent_folder, file_size, mime_type, created_at
            FROM files
            WHERE parent_folder = %s
            ORDER BY type DESC, name ASC
        """, (folder,))

        files = []
        for row in cursor.fetchall():
            files.append({
                'id': row[0],
                'name': row[1],
                'type': row[2],
                'parent_folder': row[3],
                'file_size': row[4],
                'mime_type': row[5],
                'created_at': row[6].isoformat() if row[6] else None
            })

        cursor.close()
        conn.close()
        return jsonify({'files': files})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/folder', methods=['POST'])
def create_folder():
    """Create a new folder"""
    try:
        data = request.json
        name = data.get('name')
        parent_folder = data.get('parent_folder', '/')

        if not name:
            return jsonify({'error': 'Folder name required'}), 400

        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO files (name, type, parent_folder)
            VALUES (%s, %s, %s)
            RETURNING id
        """, (name, 'folder', parent_folder))

        folder_id = cursor.fetchone()[0]
        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({'success': True, 'id': folder_id})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/upload', methods=['POST'])
def upload_file():
    """Upload a file"""
    try:
        data = request.json
        name = data.get('name')
        parent_folder = data.get('parent_folder', '/')
        file_data = data.get('file_data')  # base64 encoded
        mime_type = data.get('mime_type')
        file_size = data.get('file_size', 0)

        if not name or not file_data:
            return jsonify({'error': 'File name and data required'}), 400

        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO files (name, type, parent_folder, file_data, file_size, mime_type)
            VALUES (%s, %s, %s, %s, %s, %s)
            RETURNING id
        """, (name, 'file', parent_folder, file_data, file_size, mime_type))

        file_id = cursor.fetchone()[0]
        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({'success': True, 'id': file_id})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/<int:file_id>', methods=['GET'])
def download_file(file_id):
    """Download a file"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT name, file_data, mime_type
            FROM files
            WHERE id = %s AND type = 'file'
        """, (file_id,))

        result = cursor.fetchone()
        cursor.close()
        conn.close()

        if not result:
            return jsonify({'error': 'File not found'}), 404

        name, file_data, mime_type = result

        return jsonify({
            'name': name,
            'file_data': file_data,
            'mime_type': mime_type
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/files/<int:file_id>', methods=['DELETE'])
def delete_file(file_id):
    """Delete a file or folder"""
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            DELETE FROM files WHERE id = %s
        """, (file_id,))
        conn.commit()
        cursor.close()
        conn.close()

        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting Secret Database API on http://localhost:5000")
    app.run(debug=True, port=5000)
